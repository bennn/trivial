Thanks!

1. The purpose of this pearl is to describe a language-agnostic technique
   for augmenting the rich "simple" type systems of functional languages
   ---via libraries that any programmer may implement and even prove correct.

2. Typed Racket serves as the vehicle for a sample implementation for a
   range of concrete augmentations, because it allows us to fit the ENTIRE
   CORE IMPLEMENTATION into the paper. We will supply the remaining few
   bits. The existing page limits accommodate this addition; more than
   suffices; we just thought they were too obvious.

   [[The pearl also illustrates the power of Racket's macro expander once
   again, but this has been shown many times before and is NOT the goal.]]

3. It is correct that neither our elaboration mechanism nor our examples in
   Section 3 are new. That is precisely why this is a PEARL and NOT A
   RESEARCH PAPER.

   Like any other functional pearl, ours demonstrates a novel combination
   of old ideas with concise, elegant code (basically functional rewrite
   rules on syntax).

   * Any programmer can use our technique to implement a type system
     extension as a library. (The Typed Racket implementation is
     validation.)

   * Our technique is compositional.  All examples are local transformation
     that structurally traverse arbitrarily deep expressions to synthesize
     [check] types in a hierarchical manner.

   * The guarantees for an augmented type system are as strong as a type
     system designed in a holistic manner.

     The proof obligations for such basic guarantees are stated explicitly
     in section 2.

     Specific guarantees like "the new division function raises
     compile-time errors when called with 0 denominators" are theorems
     that may be stated and proven correct in the same way as Haskell's or
     ML's type system is proven correct.

     The examples are chosen precisely because they suggest theorems that a
     programmer might wish to prove. Doing so is, however, beyond the scope
     of a pearl that demonstrates how unusual but elegant functional code
     can achieve this highly desirable goal.

================================================================================
=== END OF FORMAL RESPONSE. Detailed comments to reviewers (RA RB RC) follow.
================================================================================

--------------------------------------------------------------------------------
--- RA RB, re: translating the ideas to Typed Clojure, Scala, and Rust

  These languages have equally powerful syntax extensions as Racket.
  The tools are just less mature and less documented.

  * Clojure's macros are arbitrary rewrite rules interspersed with
    normal Clojure code run at compile-time.

  * Scala's Lightweight Modular Staging (LMS) [1] framework can implement
    rewrite rules and compile-time partial evaluation. We believe it
    can also simulate identifier macros; if not, Scala's compiler plugin API [2]
    definitely can.

  * Rust's macros cannot implement our interpretation functions, but
    their compiler plugins [3] are on-par with Scala's.

  Sources:
    [1] https://scala-lms.github.io/
    [2] http://www.scala-lang.org/old/node/8656
    [3] https://doc.rust-lang.org/book/compiler-plugins.html


--------------------------------------------------------------------------------
--- RA RB, re: (printf "~a")

   Calling (printf "~a") raises an arity error in our implementation because
   "~a" is a valid format specifier yet `printf` is called with zero additional
   arguments.
   Calling (printf "~b") would give the same arity error.
   These both compile in Typed Racket but fail at runtime.

   But writing (printf "~a") was a typo on our part.
   We intended to use "~s" instead.

   The final version of the paper will give actual error messages instead of
   using ‚ä•.


--------------------------------------------------------------------------------
--- RA, re: Dialyzer

   The Dialyzer belongs in our discussion of related work.
   Its guarantee matches our third requirement for elaborations
   (statically rejected programs will go wrong at runtime).

   The PEPM'13 paper is interesting, but orthogonal to our pearl.

   - We are seeking to catch more runtime errors statically and allow more
     dynamically-correct programs that fail to typecheck as written.

   - Sagonas, Silva, and Tamarit are computing program slices to improve
     the quality of type error messages.

   But their technique would be very useful for Typed Racket.


-----------------------------------------------------------------------------
--- RA, re: using #false in interpretations

   This was a careless error on our part.
   We meant to use a unique sentinel value.


--------------------------------------------------------------------------------
--- RA, re: how many casts and annotations were made redundant?

   We removed casts around every call to `regexp-match` we found in typed code.
   But that was only 10 calls and unfortunately we found no typed programs
   using SQL.

   But aside from removing casts, the library is also useful for early detection
   of bugs when writing programs.
   Our personal experience has been good and we are currently soliciting
   feedback from Typed Racket users


--------------------------------------------------------------------------------
--- RA, re: the quality of type error messages

   Compile errors raised by our implementation point out exactly what values
   caused the local transformation to fail. These are easy to read.

   Type errors raised in post-elaboration code are (so far) caused by introduced
   type annotations. These errors are concise, but could use more context.

   e.g. the error for (printf "~b" 3.14) says that 3.14 has the wrong type,
   but does not cite the format string "~b" as the reason why.


--------------------------------------------------------------------------------
--- RB, re: "most languages fail at runtime" on printf

   gcc does indeed print a warning for invalid & mismatched format specifiers.
   It also complains when called on non-literal strings.
   OCaml also catches printf type errors.

   We will say "many languages fail" instead of "most".


--------------------------------------------------------------------------------
--- RC, re: flow of Sec. 3

   RC writes:

       "The example calls ... don't really drive the point home.
        I would have expected a couple of examples along the
        following lines: here is what I have to write without the
        system and here is what I can write using the system."

   This is a weakness of our presentation.
   We will clarify the problems solved by each example.
